package fr.inrae.act.bagap.chloe.concept.grainbocager.analysis.procedure.farm;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;

import org.geotools.data.shapefile.dbf.DbaseFileHeader;
import org.geotools.data.shapefile.dbf.DbaseFileReader;
import org.geotools.data.shapefile.files.ShpFiles;
import org.geotools.data.shapefile.shp.ShapefileException;
import org.geotools.data.shapefile.shp.ShapefileReader;
import org.jumpmind.symmetric.csv.CsvWriter;
import org.locationtech.jts.geom.Envelope;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.GeometryFactory;

import fr.inrae.act.bagap.apiland.raster.Coverage;
import fr.inrae.act.bagap.apiland.raster.CoverageManager;
import fr.inrae.act.bagap.apiland.raster.EnteteRaster;
import fr.inrae.act.bagap.apiland.raster.converter.ShapeFile2CoverageConverter;
import fr.inrae.act.bagap.chloe.util.Util;

public class DiagnosticGrainBocagerExploitationManager {

	private String attributCodeEA;			// attribut de code exploitation
	
	private double[] thresholds; 			// seuil d'observation du grain bocager, le seuil de fonctionnalite est le deuxi�me
	
	private String outputFolder; 			// dossier de generation des sorties
	
	private String parcellaire;				// shapefile du parcellaire de l'exploitation
	
	private EnteteRaster entete;			// entete raster de travail
	
	private String bocage;					// hauteur de boisement
	
	private String codeEA; 					// code exploitation
	
	private String amenagement;				// lineaire bocagere imagine
	
	private String scenario; 				// scenario a traiter
	
	private String attributScenario;		// attribut du scenario
	
	private double grainBocagerCellSize; 	// taille de la resolution de sortie
	
	private double grainBocagerWindowRadius;// taille de la fen�tre d'analyse pour le grain bocager
	
	private CsvWriter writer;				// writer sur fichier
	
	private boolean exportMap; 				// map exportation
	
	private int buffer; 				// buffer d'influence en metres 
	
	public DiagnosticGrainBocagerExploitationManager(){
		init();
	}

	private void init(){
		
		// attributs avec valeur par defaut
		attributCodeEA = "id_ea";
		thresholds = new double[]{0.2, 0.33, 0.45};
		scenario = "initial";
		attributScenario = null;
		grainBocagerCellSize = 5;
		grainBocagerWindowRadius = 250.0;
		exportMap = false;
		buffer = 500;
		outputFolder = new File(System.getProperty("java.io.tmpdir")).toString().replace("\\", "/")+"/grain_bocager_exploitation/";
		Util.createAccess(outputFolder);
		
		// attributs a redefinir
		parcellaire = null;
		bocage = null;
		codeEA = null;
		amenagement = null;
		writer = null;
	}
	
	// setters
	
	public void setWriter(CsvWriter writer){
		this.writer = writer;
	}
	
	public void setScenario(String scenario) {
		this.scenario = scenario;
	}
	
	public void setAttributScenario(String attributScenario) {
		this.attributScenario = attributScenario;
	}

	public void setAttributCodeEA(String attributeCodeEA) {
		this.attributCodeEA = attributeCodeEA;
	}

	public void setThresholds(double threshold1, double threshold2, double threshold3) {
		this.thresholds[0] = threshold1;
		this.thresholds[1] = threshold2;
		this.thresholds[2] = threshold3;
	}

	public void setOutputFolder(String outputFolder) {
		Util.createAccess(outputFolder);
		this.outputFolder = outputFolder;
		if(!this.outputFolder.endsWith("/")) {
			this.outputFolder += "/";
		}
	}
	
	public void setGrainBocagerCellSize(double grainBocagerCellSize){
		this.grainBocagerCellSize = grainBocagerCellSize;
	}
	
	public void setGrainBocagerWindowRadius(double grainWindowRadius){
		this.grainBocagerWindowRadius = grainWindowRadius;
	}

	public void setParcellaire(String parcellaire) {
		this.parcellaire = parcellaire;
	}

	public void setBocage(String bocage) {
		this.bocage = bocage;
	}

	public void setAmenagement(String amenagement) {
		this.amenagement = amenagement;
	}

	public void setCodeEA(String codeEA) {
		this.codeEA = codeEA;
	}
	
	public void setExportMap(boolean exportMap) {
		this.exportMap = exportMap;
	}
	
	// getters

	public String attributCodeEA() {
		return attributCodeEA;
	}

	public double threshold() {
		return thresholds[1];
	}
	
	public double[] thresholds() {
		return thresholds;
	}

	public String outputFolder() {
		return outputFolder;
	}

	public String parcellaire() {
		return parcellaire;
	}

	public String bocage() {
		return bocage;
	}

	public String codeEA() {
		return codeEA;
	}

	public String amenagement() {
		return amenagement;
	}

	public String scenario() {
		return scenario;
	}
	
	public String attributScenario() {
		return attributScenario;
	}

	public double grainBocagerCellSize() {
		return grainBocagerCellSize;
	}
	
	public double grainBocagerWindowRadius() {
		return grainBocagerWindowRadius;
	}

	public CsvWriter writer() {
		return writer;
	}

	public boolean exportMap() {
		return exportMap;
	}
	
	public int buffer() {
		return buffer;
	}
	
	public EnteteRaster entete() {
		return entete;
	}
	
	// build
	
	private boolean initEntete(){
		
		if(parcellaire != null && bocage != null){
			
			// recuperation de l'entete du bocage
			Coverage covBocage = CoverageManager.getCoverage(bocage);
			EnteteRaster enteteBocage = covBocage.getEntete();
			covBocage.dispose();
			
			// recuperation de l'enveloppe totale de travail
			Envelope envelope = ShapeFile2CoverageConverter.getEnvelope(parcellaire, buffer*2, attributCodeEA, codeEA);
			
			// recuperation de l'entete
			entete = EnteteRaster.getEntete(enteteBocage, envelope);
			
			return true;
		}
		
		return false;
	}
	
	private boolean check(){
		boolean ok = true;
		if(attributCodeEA == null || attributCodeEA.equalsIgnoreCase("")){
			System.out.println("attribute for code farm 'attributCodeEA' is missing");
			ok = false;
		}
		if(outputFolder == null || outputFolder.equalsIgnoreCase("")){
			System.out.println("output folder 'outpath' is missing");
			//ok = false;
		}
		if(parcellaire == null || parcellaire.equalsIgnoreCase("")){
			System.out.println("input shapefile for 'parcellaire' is missing");
			ok = false;
		}
		if(bocage == null || bocage.equalsIgnoreCase("")){
			System.out.println("input file for 'bocage' is missing");
			ok = false;
		}
		if(codeEA == null || codeEA.equalsIgnoreCase("")){
			System.out.println("code farm 'codeEA' is missing");
			ok = false;
		}
		if(scenario == null || scenario.equalsIgnoreCase("")){
			System.out.println("scenario name 'scenario' is missing");
			ok = false;
		}
		if(grainBocagerCellSize < 5 && grainBocagerCellSize%5!=0){
			System.out.println("output cellsize parameter 'grain_bocager_cellsize' is unconsistant "+grainBocagerCellSize);
			ok = false;
		}
		return ok;
	}
	
	public DiagnosticGrainBocagerExploitation build(){
		
		if(check()){
			if(initEntete()){
				//DiagnosticGrainBocagerExploitation diagEA = new DiagnosticGrainBocagerExploitation(outputFolder, parcellaire, /*zoneBocageExploitation,*/ /*bufferZoneBocageExploitation,*/ bocage, attributCodeEA, attributSecteur, codeEA, threshold, amenagement, scenarios, grainBocagerCellsize, cw, exportMap);
				DiagnosticGrainBocagerExploitation diagEA = new DiagnosticGrainBocagerExploitation(this);
				
				//reset();
				return diagEA;
			}
		}
		throw new IllegalArgumentException("parameters are unconsistant");
	}
	
}

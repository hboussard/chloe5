package fr.inrae.act.bagap.chloe.concept.grainbocager.analysis.farm;

import java.util.HashSet;
import java.util.Set;

import org.jumpmind.symmetric.csv.CsvWriter;

public class DiagnosticGrainBocagerExploitationBuilder {

	private String attributCodeEA;			// attribut de code exploitation
	
	private String attributSecteur;			// attribut des secteurs
	
	private double seuil; 					// seuil de fonctionnalite du grain bocager
	
	private String outputPath; 				// dossier de génération des sorties
	
	private String parcellaire;				// shapefile du parcellaire de l'exploitation
	
	private String zoneBocageExploitation;	// shapefile des zones bocagères appartenant à l'exploitation
	
	private double bufferZoneBocageExploitation; // buffer autour du bocage de l'exploitation
	
	private String bocage;					// tuiles MNHC
	
	private String codeEA; 					// code exploitation
	
	private String replantationBocagere;	// lineaire bocagere imagine
	
	private Set<String> scenarios; 			// scenarios a traiter
	
	private double outCellSize; 			// taille de la resolution de sortie
	
	private CsvWriter cw;					// writer sur fichier
	
	public DiagnosticGrainBocagerExploitationBuilder(){
		reset();
	}

	private void reset(){
		
		// attributs avec valeur par défaut
		attributCodeEA = "id_ea";
		attributSecteur = "secteur";
		seuil = 0.4;
		scenarios = new HashSet<String>();
		outCellSize = 5;
		bufferZoneBocageExploitation = 0;
		
		// attributs à redéfinir obligatoirement
		outputPath = "";
		parcellaire = "";
		zoneBocageExploitation = "";
		bocage = "";
		codeEA = ""; 
		
		// attributs facultatifs
		replantationBocagere = "";
		cw = null;
	}
	
	public void setCsvWriter(CsvWriter cw){
		this.cw = cw;
	}
	
	public void addScenario(String scenario) {
		scenarios.add(scenario);
	}

	public void setAttributCodeEA(String attributeCodeEA) {
		this.attributCodeEA = attributeCodeEA;
	}

	public void setAttributSecteur(String attributeSecteur) {
		this.attributSecteur = attributeSecteur;
	}

	public void setSeuil(double seuil) {
		this.seuil = seuil;
	}

	public void setOutputPath(String outputPath) {
		this.outputPath = outputPath;
	}
	
	public void setOutCellSize(double outCellSize){
		this.outCellSize = outCellSize;
	}

	public void setParcellaire(String parcellaire) {
		this.parcellaire = parcellaire;
	}

	public void setZoneBocageExploitation(String zoneBocageExploitation) {
		this.zoneBocageExploitation = zoneBocageExploitation;
	}
	
	public void setBufferZoneBocageExploitation(double bufferZoneBocageExploitation) {
		this.bufferZoneBocageExploitation = bufferZoneBocageExploitation;
	}

	public void setBocage(String bocage) {
		this.bocage = bocage;
	}

	public void setReplantationBocagere(String replantationBocagere) {
		this.replantationBocagere = replantationBocagere;
	}

	public void setCodeEA(String codeEA) {
		this.codeEA = codeEA;
	}
	
	private boolean check(){
		boolean ok = true;
		if(attributCodeEA.equalsIgnoreCase("")){
			System.out.println("attribute for code farm 'attributCodeEA' is missing");
			ok = false;
		}
		if(attributSecteur.equalsIgnoreCase("")){
			System.out.println("attribute for farm sectors 'attributSecteur' is missing");
			ok = false;
		}
		if(seuil<0 || seuil>1){
			System.out.println("threshold parameter 'seuil' is unconsistant "+seuil);
			ok = false;
		}
		if(outputPath.equalsIgnoreCase("")){
			System.out.println("output folder 'outpath' is missing");
			//ok = false;
		}
		if(parcellaire.equalsIgnoreCase("")){
			System.out.println("input shapefile for 'parcellaire' is missing");
			ok = false;
		}
		if(zoneBocageExploitation.equalsIgnoreCase("")){
			System.out.println("input shapefile for 'zoneBocageExploitation' is missing");
			ok = false;
		}
		if(bocage.equalsIgnoreCase("")){
			System.out.println("input MNHC folder for 'bocage' is missing");
			ok = false;
		}
		if(codeEA.equalsIgnoreCase("")){
			System.out.println("code farm 'codeEA' is missing");
			ok = false;
		}
		if(scenarios.size() == 0){
			scenarios.add("existant");
		}
		if(outCellSize < 5 && outCellSize%5!=0){
			System.out.println("output cellsize parameter 'outCellSize' is unconsistant "+outCellSize);
			ok = false;
		}
		return ok;
	}
	
	public DiagnosticGrainBocagerExploitation build(){
		
		if(check()){
			DiagnosticGrainBocagerExploitation diagEA = new DiagnosticGrainBocagerExploitation(outputPath, parcellaire, zoneBocageExploitation, bufferZoneBocageExploitation, bocage, attributCodeEA, attributSecteur, codeEA, seuil, replantationBocagere, scenarios, outCellSize, cw);
			reset();
			return diagEA;
		}
		throw new IllegalArgumentException("parameters are unconsistant");
	}
	
}

package fr.inrae.act.bagap.chloe.concept.grainbocager.analysis.procedure.farm;

import java.io.IOException;
import java.nio.charset.Charset;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

import org.geotools.data.shapefile.dbf.DbaseFileHeader;
import org.geotools.data.shapefile.dbf.DbaseFileReader;
import org.geotools.data.shapefile.files.ShpFiles;
import org.geotools.data.shapefile.shp.ShapefileException;
import org.geotools.data.shapefile.shp.ShapefileReader;
import org.jumpmind.symmetric.csv.CsvWriter;
import org.locationtech.jts.geom.Envelope;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.GeometryFactory;

import fr.inrae.act.bagap.apiland.analysis.tab.Pixel2PixelTabCalculation;
import fr.inrae.act.bagap.apiland.util.Tool;
import fr.inrae.act.bagap.chloe.distance.analysis.euclidian.TabChamferDistanceAnalysis;
import fr.inrae.act.bagap.chloe.util.Util;
import fr.inrae.act.bagap.apiland.raster.Coverage;
import fr.inrae.act.bagap.apiland.raster.CoverageManager;
import fr.inrae.act.bagap.apiland.raster.EnteteRaster;
import fr.inrae.act.bagap.apiland.raster.converter.ShapeFile2CoverageConverter;
import fr.inrae.act.bagap.chloe.concept.grainbocager.analysis.GrainBocager;
import fr.inrae.act.bagap.chloe.concept.grainbocager.analysis.procedure.GrainBocagerManager;

public class DiagnosticGrainBocagerExploitation {

	private static int buffer = 500; 	// buffer d'influence en metres 
										// 300m pour le calcul des distances
										// 250m pour la fenetre glissante 
	
	private static DecimalFormat format;
	static{
		DecimalFormatSymbols symbols = new DecimalFormatSymbols();
		symbols.setDecimalSeparator('.');
		format = new DecimalFormat("0.000", symbols);
	}
	
	private String outputPath; // dossier de generation des sorties
	
	private String parcellaire; // shapefile du parcellaire de l'exploitation
	
	//private String zoneBocageExploitation; // shapefile des zones bocageres appartenant a l'exploitation
	
	//private double bufferZoneBocageExploitation; // buffer autour du bocage de l'exploitation
	
	private String bocage; // tuiles MNHC
	
	private String attributeCodeEA; // attribut de code exploitation
	
	private String attributeSecteur; // attribut des secteurs
	
	private String codeEA; // code exploitation
	
	private double seuil; // seuil de fonctionnalite du grain bocager
	
	private double[] seuils = new double[]{0.2, 0.33, 0.45}; 
	
	private String amenagement; // modifications bocagere imaginees
	
	private Set<String> scenarios; // scenarios a tester
	
	private String[] secteurs;
	
	private EnteteRaster refEntete;
	
	private double outCellSize;
	
	private CsvWriter writer;					// writer sur fichier
	
	private boolean exportMap;
	
	public DiagnosticGrainBocagerExploitation(String outputPath, String parcellaire, /*String zoneBocageExploitation,*/ /*double bufferZoneBocageExploitation,*/ 
			String bocage, String attributeCodeEA, String attributeSecteur, String codeEA, double seuil, String amenagement, Set<String> scenarios, double outCellSize, CsvWriter writer, boolean exportMap){
		this.outputPath = outputPath;
		this.parcellaire = parcellaire;
		//this.zoneBocageExploitation = zoneBocageExploitation;
		//this.bufferZoneBocageExploitation = bufferZoneBocageExploitation;
		this.bocage = bocage;
		this.attributeCodeEA = attributeCodeEA;
		this.attributeSecteur = attributeSecteur;
		this.codeEA = codeEA;
		this.seuil = seuil;
		this.amenagement = amenagement;
		this.scenarios = scenarios;
		this.outCellSize = outCellSize;
		this.writer = writer;
		this.exportMap = exportMap;
	}
	
	public boolean run(){
		
		// creation du repertoire de sortie
		//Util.createAccess(outputPath);
		
		// recuperation de l'enveloppe totale de travail
		Envelope envelope = getEnvelope("total");
		
		if(envelope.getMaxX()-envelope.getMinX() > 15000
				|| envelope.getMaxY()-envelope.getMinY() > 15000){
			System.out.println("trop eclate");
			return false;
			// do nothing
		}else{
			
			// recuperation des secteurs
			//secteurs = getSecteurs();
			
			// recuperation de l'entete
			Coverage covBocage = CoverageManager.getCoverage(bocage);
			refEntete = covBocage.getEntete();
			covBocage.dispose();
			refEntete = EnteteRaster.getEntete(refEntete, envelope);
			
			// run diagnostic
			for(String scenario : scenarios){
				System.out.println(scenario);
				runDiagnostic(scenario);
			}
			
			return true;
		}
	}
	
	private void runDiagnostic(String scenario) {
		
		// preparation des indices de sortie
		boolean manageWriter = false;
		if(writer == null){
			writer = prepareIndices(outputPath+codeEA+"/"+"diag_"+codeEA+"_"+scenario+".csv");
			manageWriter = true;
		}
			
		// lancement du diagnostic
		runDiagnostic(scenario, "total");
		/*
		// par secteur
		for(String secteur : secteurs){
			runDiagnostic(scenario, secteur);
		}*/
		
		// fermeture du fichier de sortie
		if(manageWriter){
			fermeIndices(writer);
			writer = null;
		}
	}
	
	public static void fermeIndices(CsvWriter writer){
		writer.close();
	}
	
	private void runDiagnostic(String scenario, String secteur) {
		
		if(scenario.equalsIgnoreCase("initial")) {
		
			runDiagnosticInitial(scenario, secteur);
		
		}else {
			
			runDiagnosticScenarise(scenario, secteur);
		}
	}
	
	private void runDiagnosticInitial(String scenario, String secteur) {
		
		// recuperation de l'enveloppe totale de travail
		Envelope envelope = getEnvelope(secteur);
		//System.out.println(envelope);
		
		// recuperation de l'entete initiale
		EnteteRaster entete = EnteteRaster.getEntete(refEntete, envelope);
		//System.out.println(entete);
		
		// recuperation du raster (5m) du parcellaire de l'exploitation
		// avec "1" = dans l'exploitation
		// "0" = externe a l'exploitation mais dans l'emprise d'influence (<500m)
		// "-1" = externe a l'emprise d'influence
		float[] dataParcellaire = getParcellaire(entete);
		 
		// boisement
		float[] dataHauteurBoisement = getElementsBoises(dataParcellaire, entete, scenario, null, true, true);
		
		// calcul du grain bocager
		Coverage covTypeBoisement = GrainBocager.detectionTypeBoisement(dataHauteurBoisement, entete, true);
		float[] dataTypeBoisement = covTypeBoisement.getData();
		covTypeBoisement.dispose();
		
		Coverage covDistanceInfluence = GrainBocager.calculDistancesInfluences(dataHauteurBoisement, dataTypeBoisement, entete, true);
		float[] dataDistanceInfluence = covDistanceInfluence.getData();
		covDistanceInfluence.dispose();
		
		Coverage covGrainBocager = GrainBocager.calculGrainBocager(dataDistanceInfluence, entete, 250, 5, true);
		float[] dataGrainBocager = covGrainBocager.getData();
		covGrainBocager.dispose();
				
		Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(dataGrainBocager, dataGrainBocager, dataParcellaire){
			@Override
			protected float doTreat(float[] v) {
				float vp = v[1];
				if((vp == 1 || vp == 2)) { 
					return v[0];
				}
				return entete.noDataValue();
			}
		};
		pptc.run();
		
 		Coverage covGrainBocager4Classes = GrainBocager.runClassificationNClasses(dataGrainBocager, entete, entete.noDataValue(), seuils);
 		float[] dataGrainBocager4Classes = covGrainBocager4Classes.getData();
 		covGrainBocager4Classes.dispose();
		
		// boisement externe
		float[] dataHauteurBoisementExterne = getElementsBoises(dataParcellaire, entete, scenario, null, false, true);
		
		// calcul du grain bocager externe
		float[] dataTypeBoisementExterne = getTypeBoisement(dataTypeBoisement, dataParcellaire, entete, false, true);
		
		Coverage covDistanceInfluenceExterne = GrainBocager.calculDistancesInfluences(dataHauteurBoisementExterne, dataTypeBoisementExterne, entete, true);
		float[] dataDistanceInfluenceExterne = covDistanceInfluenceExterne.getData();
		covDistanceInfluenceExterne.dispose();
		
		Coverage covGrainBocagerExterne = GrainBocager.calculGrainBocager(dataDistanceInfluenceExterne, entete, 250, 5, true);
		float[] dataGrainBocagerExterne = covGrainBocagerExterne.getData();
		covGrainBocagerExterne.dispose();
		
		pptc = new Pixel2PixelTabCalculation(dataGrainBocagerExterne, dataGrainBocagerExterne, dataParcellaire){
			@Override
			protected float doTreat(float[] v) {
				float vp = v[1];
				if((vp == 1 || vp == 2)) { 
					return v[0];
				}
				return entete.noDataValue();
			}
		};
		pptc.run();
		
		Coverage covGrainBocagerExterne4Classes = GrainBocager.runClassificationNClasses(dataGrainBocagerExterne, entete, entete.noDataValue(), seuils);
 		float[] dataGrainBocagerExterne4Classes = covGrainBocagerExterne4Classes.getData();
 		covGrainBocagerExterne4Classes.dispose();
 		
 		if(exportMap) {
			Util.createAccess(outputPath+codeEA+"/");
			CoverageManager.writeGeotiff(outputPath+codeEA+"/"+"ea_"+secteur+"_"+codeEA+".tif", dataParcellaire, entete);
			CoverageManager.writeGeotiff(outputPath+codeEA+"/"+"hauteur_boisement_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataHauteurBoisement, entete);
			CoverageManager.writeGeotiff(outputPath+codeEA+"/"+"type_boisement_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataTypeBoisement, entete);
			CoverageManager.writeGeotiff(outputPath+codeEA+"/"+"grain_bocager_"+secteur+"_"+codeEA+"_"+scenario+"_4classes.tif", dataGrainBocager4Classes, entete);
			CoverageManager.writeGeotiff(outputPath+codeEA+"/"+"grain_bocager_"+secteur+"_"+codeEA+"_externe_4classes.tif", dataGrainBocagerExterne4Classes, entete);
			CoverageManager.writeGeotiff(outputPath+codeEA+"/"+"grain_bocager_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataGrainBocager, entete);
			CoverageManager.writeGeotiff(outputPath+codeEA+"/"+"grain_bocager_"+secteur+"_"+codeEA+"_externe.tif", dataGrainBocagerExterne, entete);
			
			try {
				Tool.copy(GrainBocagerManager.class.getResourceAsStream("style_ea.qml"), outputPath+codeEA+"/"+"ea_"+secteur+"_"+codeEA+".qml");
				Tool.copy(GrainBocagerManager.class.getResourceAsStream("style_hauteur_boisement.qml"), outputPath+codeEA+"/"+"hauteur_boisement_"+secteur+"_"+codeEA+"_"+scenario+".qml");
				Tool.copy(GrainBocagerManager.class.getResourceAsStream("style_type_boisement.qml"), outputPath+codeEA+"/"+"type_boisement_"+secteur+"_"+codeEA+"_"+scenario+".qml");
				Tool.copy(GrainBocagerManager.class.getResourceAsStream("style_grain_bocager.qml"), outputPath+codeEA+"/"+"grain_bocager_"+secteur+"_"+codeEA+"_"+scenario+".qml");
				Tool.copy(GrainBocagerManager.class.getResourceAsStream("style_grain_bocager.qml"), outputPath+codeEA+"/"+"grain_bocager_"+secteur+"_"+codeEA+"_externe.qml");
				Tool.copy(GrainBocagerManager.class.getResourceAsStream("style_grain_bocager_4classes.qml"), outputPath+codeEA+"/"+"grain_bocager_"+secteur+"_"+codeEA+"_"+scenario+"_4classes.qml");
				Tool.copy(GrainBocagerManager.class.getResourceAsStream("style_grain_bocager_4classes.qml"), outputPath+codeEA+"/"+"grain_bocager_"+secteur+"_"+codeEA+"_externe_4classes.qml");
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
 		
		// calcul des indices et export
		calculIndices(writer, scenario, secteur, dataParcellaire, dataHauteurBoisement, dataTypeBoisement, dataGrainBocager, dataGrainBocager4Classes, dataGrainBocagerExterne, dataGrainBocagerExterne4Classes, outCellSize);
		
	}
	
	private void runDiagnosticScenarise(String scenario, String secteur) {
		
		// recuperation du parcellaire et de l'entete
		Coverage covParcellaire = CoverageManager.getCoverage(outputPath+codeEA+"/"+"ea_"+secteur+"_"+codeEA+".tif");
		float[] dataParcellaire = covParcellaire.getData();
		EnteteRaster entete = covParcellaire.getEntete();
		covParcellaire.dispose();
		 
		// boisement total
		float[] dataHauteurBoisement = getElementsBoises(dataParcellaire, entete, scenario, amenagement, true, true);
		
		// calcul du grain bocager
		Coverage covTypeBoisement = GrainBocager.detectionTypeBoisement(dataHauteurBoisement, entete, true);
		float[] dataTypeBoisement = covTypeBoisement.getData();
		covTypeBoisement.dispose();
		
		Coverage covTypeBoisementInitial = CoverageManager.getCoverage(outputPath+codeEA+"/"+"type_boisement_"+secteur+"_"+codeEA+"_initial.tif");
		float[] dataTypeBoisementInitial = covTypeBoisementInitial.getData();
		covTypeBoisementInitial.dispose();
		
		dataTypeBoisement = getTypeBoisement(dataTypeBoisement, dataTypeBoisementInitial, entete);
		
		Coverage covDistanceInfluence = GrainBocager.calculDistancesInfluences(dataHauteurBoisement, dataTypeBoisement, entete, true);
		float[] dataDistanceInfluence = covDistanceInfluence.getData();
		covDistanceInfluence.dispose();
		
		Coverage covGrainBocager = GrainBocager.calculGrainBocager(dataDistanceInfluence, entete, 250, 5, true);
		float[] dataGrainBocager = covGrainBocager.getData();
		covGrainBocager.dispose();
				
		Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(dataGrainBocager, dataGrainBocager, dataParcellaire){
			@Override
			protected float doTreat(float[] v) {
				float vp = v[1];
				if((vp == 1 || vp == 2)) { 
					return v[0];
				}
				return entete.noDataValue();
			}
		};
		pptc.run();
		
 		Coverage covGrainBocager4Classes = GrainBocager.runClassificationNClasses(dataGrainBocager, entete, entete.noDataValue(), seuils);
 		float[] dataGrainBocager4Classes = covGrainBocager4Classes.getData();
 		covGrainBocager4Classes.dispose();
		
		// boisement externe
 		Coverage covGrainBocagerExterne = CoverageManager.getCoverage(outputPath+codeEA+"/"+"grain_bocager_"+secteur+"_"+codeEA+"_externe.tif");
		float[] dataGrainBocagerExterne = covGrainBocagerExterne.getData();
		covGrainBocagerExterne.dispose();
		
		Coverage covGrainBocagerExterne4Classes = CoverageManager.getCoverage(outputPath+codeEA+"/"+"grain_bocager_"+secteur+"_"+codeEA+"_externe_4classes.tif");
 		float[] dataGrainBocagerExterne4Classes = covGrainBocagerExterne4Classes.getData();
 		covGrainBocagerExterne4Classes.dispose();
 		
 		if(exportMap) {
			Util.createAccess(outputPath+codeEA+"/");
			CoverageManager.writeGeotiff(outputPath+codeEA+"/"+"hauteur_boisement_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataHauteurBoisement, entete);
			CoverageManager.writeGeotiff(outputPath+codeEA+"/"+"type_boisement_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataTypeBoisement, entete);
			CoverageManager.writeGeotiff(outputPath+codeEA+"/"+"grain_bocager_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataGrainBocager, entete);
			CoverageManager.writeGeotiff(outputPath+codeEA+"/"+"grain_bocager_"+secteur+"_"+codeEA+"_"+scenario+"_4classes.tif", dataGrainBocager4Classes, entete);
			
			try {
				Tool.copy(GrainBocagerManager.class.getResourceAsStream("style_hauteur_boisement.qml"), outputPath+codeEA+"/"+"hauteur_boisement_"+secteur+"_"+codeEA+"_"+scenario+".qml");
				Tool.copy(GrainBocagerManager.class.getResourceAsStream("style_type_boisement.qml"), outputPath+codeEA+"/"+"type_boisement_"+secteur+"_"+codeEA+"_"+scenario+".qml");
				Tool.copy(GrainBocagerManager.class.getResourceAsStream("style_grain_bocager.qml"), outputPath+codeEA+"/"+"grain_bocager_"+secteur+"_"+codeEA+"_"+scenario+".qml");
				Tool.copy(GrainBocagerManager.class.getResourceAsStream("style_grain_bocager_4classes.qml"), outputPath+codeEA+"/"+"grain_bocager_"+secteur+"_"+codeEA+"_"+scenario+"_4classes.qml");
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
 		
		// calcul des indices et export
		calculIndices(writer, scenario, secteur, dataParcellaire, dataHauteurBoisement, dataTypeBoisement, dataGrainBocager, dataGrainBocager4Classes, dataGrainBocagerExterne, dataGrainBocagerExterne4Classes, outCellSize);
		
	}
	
	private float[] getTypeBoisement(float[] dataTypeBoisement, float[] dataParcellaire, EnteteRaster entete, boolean interne, boolean externe) {
		
		float[] data = new float[entete.width()*entete.height()];
		
		Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(data, dataTypeBoisement, dataParcellaire){
			@Override
			protected float doTreat(float[] v) {
				float vp = v[1];
				if((vp == 0 || vp == 2) && externe) { // exterieur de l exploitation
					return v[0];
				}
				if(vp == 1 && interne) { // exterieur de l exploitation
					return v[0];
				}
				return entete.noDataValue();
			}
		};
		pptc.run();
		
		return data;
	}
	
	private float[] getTypeBoisement(float[] dataTypeBoisement, float[] dataTypeBoisementInitial, EnteteRaster entete) {
		
		Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(dataTypeBoisement, dataTypeBoisement, dataTypeBoisementInitial){
			@Override
			protected float doTreat(float[] v) {
				float vtb = v[0];
				float vtbi = v[1];
				if(vtb != 0 && vtbi != 0) {
					return Math.max(vtb, vtbi);	
				}
				return vtb;
			}
		};
		pptc.run();
		
		return dataTypeBoisement;
	}
	
	private float[] getElementsBoises(float[] dataParcellaire, EnteteRaster entete, String scenario, String amenagement, boolean interne, boolean externe) {
		
		//System.out.println("recuperation des elements boises");
		
		Coverage covBoisement = CoverageManager.getCoverage(bocage);
		EnteteRaster enteteMNHC = covBoisement.getEntete();
		
		float[] dataBoisement = covBoisement.getData(EnteteRaster.getROI(enteteMNHC, entete.getEnvelope()));
		covBoisement.dispose();
		
		Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(dataBoisement, dataBoisement, dataParcellaire){
			@Override
			protected float doTreat(float[] v) {
				float vp = v[1];
				if((vp == 0 || vp == 2) && externe) { // exterieur de l exploitation
					return v[0];
				}
				if(vp == 1 && interne) { // exterieur de l exploitation
					return v[0];
				}
				return entete.noDataValue();
			}
		};
		pptc.run();
		
		if(interne && amenagement != null){
			
			float[] dataAmenagement = getAmenagements(scenario, amenagement, entete);
			
			for(int index=0; index<dataBoisement.length; index++) {
				float va = dataAmenagement[index];
				float vp = dataParcellaire[index];
				if(va != -1 && vp == 1) {
					dataBoisement[index] = va;
				}
			}
		}
		
		return dataBoisement;
	}

	private float[] getAmenagements(String scenario, String amenagement, EnteteRaster entete){
		
		//System.out.println("recuperation des amenagements");
		
		Coverage covAmenagement = GrainBocager.recuperationHauteurPlantation(amenagement, scenario, entete, -1);
		float[] dataAmenagement = covAmenagement.getData();
		covAmenagement.dispose();
			
		return dataAmenagement;
	}

	/**
	 * recuperation du raster (5m) du parcellaire de l'exploitation avec 
	 * "1" = dans l'exploitation
	 * "2" = externe a l'EA mais dans la zone d'influence (<500m)
	 * "0" = externe a l'EA mais dans la seconde zone d'influence (<1000m)
	 * "-1" = externe a la zone d'influence
	 */
	private float[] getParcellaire(EnteteRaster entete) {
		
		//System.out.println("r�cup�ration du parcellaire");
		
		Map<String, Integer> codesEA = new HashMap<String, Integer>();
		codesEA.put(codeEA, 1);
		
		Coverage covParcellaire = ShapeFile2CoverageConverter.getSurfaceCoverage(parcellaire, attributeCodeEA, codesEA, entete.cellsize(), entete.noDataValue(), entete.crs(), entete.minx(), entete.maxx(), entete.miny(), entete.maxy(), 0);
		float[] dataParcellaire = covParcellaire.getData();
		covParcellaire.dispose();
	
		int[] codes =  new int[]{1};
		float[] dataDistance = new float[entete.width() * entete.height()];
		
		TabChamferDistanceAnalysis da = new TabChamferDistanceAnalysis(dataDistance, dataParcellaire, entete.width(), entete.height(), entete.cellsize(), entete.noDataValue(), codes, entete.noDataValue());
		da.allRun();
		
		dataParcellaire = null;
		
		float[] data = new float[entete.width() * entete.height()];
		Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(data, dataDistance){
			@Override
			protected float doTreat(float[] v) {
				double value = v[0];
				if(value == 0){ // dans l'exploitation
					return 1;
				}
				if(value <= buffer){ // dans la zone d'influence
					return 2;
				}
				if(value <= 2*buffer){ // dans la zone d'influence
					return 0;
				}
				return entete.noDataValue();
			}
		};
		pptc.run();
		
		return data;
	}
	
	/*
	private float[] getZoneBocageExploitation(EnteteRaster entete, double buffer) {

		//System.out.println("r�cup�ration de la zone de bocage de l'exploitation");
		
		Map<String, Integer> codesEA = new HashMap<String, Integer>();
		codesEA.put(codeEA, 1);
		
		Coverage covZoneBocage = ShapeFile2CoverageConverter.getSurfaceCoverage(zoneBocageExploitation, attributeCodeEA, codesEA, entete.cellsize(), entete.noDataValue(), entete.crs(), entete.minx(), entete.maxx(), entete.miny(), entete.maxy(), 0);
		float[] dataZoneBocage = covZoneBocage.getData();
		covZoneBocage.dispose();
		
		if(buffer > 0){
			int[] codes =  new int[]{1};
			float[] dataDistance = new float[entete.width() * entete.height()];
			
			TabChamferDistanceAnalysis da = new TabChamferDistanceAnalysis(dataDistance, dataZoneBocage, entete.width(), entete.height(), entete.cellsize(), entete.noDataValue(), codes, entete.noDataValue());
			da.allRun();
			
			Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(dataZoneBocage, dataDistance){
				@Override
				protected float doTreat(float[] v) {
					double value = v[0];
					if(value == 0){ // dans l'exploitation
						return 1;
					}
					if(value <= buffer){ // dans la zone d'influence
						return 1;
					}
					return 0;
				}
			};
			pptc.run();
		}
		
		return dataZoneBocage;
	}*/
	
	private float[] getElementsBoises(float[] dataZoneBocageExploitation, float[] dataReplantations, EnteteRaster entete, boolean interne, boolean externe) {
		return getElementsBoises(dataZoneBocageExploitation, dataReplantations, entete, interne, externe, -1);
	}
	
	private float[] getElementsBoises(float[] dataZoneBocageExploitation, float[] dataReplantations, EnteteRaster entete, boolean interne, boolean externe, int scenar) {
		
		//System.out.println("recuperation des elements boises");
		
		Coverage covBoisement = CoverageManager.getCoverage(bocage);
		EnteteRaster enteteMNHC = covBoisement.getEntete();
		float[] dataBoisement = covBoisement.getData(EnteteRaster.getROI(enteteMNHC, new Envelope(entete.minx(), entete.maxx(), entete.miny(), entete.maxy())));
		covBoisement.dispose();
		
		if(!interne){
			
			Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(dataBoisement, dataBoisement, dataZoneBocageExploitation){
				@Override
				protected float doTreat(float[] v) {
					if(v[1] == 1){ // dans l'exploitation
						return 0;
					}
					return v[0];
				}
			};
			pptc.run();
			
		}
		if(!externe){
			
			Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(dataBoisement, dataBoisement, dataZoneBocageExploitation){
				@Override
				protected float doTreat(float[] v) {
					if(v[1] == 1){ // dans l'exploitation
						return v[0];
					}
					return 0;
				}
			};
			pptc.run();
			
		}
		if(interne && dataReplantations != null){
			
			Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(dataBoisement, dataBoisement, dataReplantations){
				@Override
				protected float doTreat(float[] v) {
					return Math.max(v[0], v[1]);
				}
			};
			pptc.run();
			
		}
		
		return dataBoisement;
	}
	
	private float[] getElementsBoisesMaximum(float[] dataZoneBocageExploitation, float[] dataReplantations, EnteteRaster entete, boolean externe) {
		return getElementsBoisesMaximum(dataZoneBocageExploitation, dataReplantations, entete, externe, -1);
	}
	
	private float[] getElementsBoisesMaximum(float[] dataZoneBocageExploitation, float[] dataReplantations, EnteteRaster entete, boolean externe, int scenar) {
		
		//System.out.println("recuperation des elements boises");
		
		Coverage covBoisement = CoverageManager.getCoverage(bocage);
		EnteteRaster enteteMNHC = covBoisement.getEntete();
		float[] dataBoisement = covBoisement.getData(EnteteRaster.getROI(enteteMNHC, new Envelope(entete.minx(), entete.maxx(), entete.miny(), entete.maxy())));
		covBoisement.dispose();
		
		Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(dataBoisement, dataBoisement, dataZoneBocageExploitation){
			@Override
			protected float doTreat(float[] v) {
				if(v[1] == 1){ // dans l'exploitation
					return 10;
				}
				return v[0];
			}
		};
		pptc.run();
			
		if(!externe){
			
			pptc = new Pixel2PixelTabCalculation(dataBoisement, dataBoisement, dataZoneBocageExploitation){
				@Override
				protected float doTreat(float[] v) {
					if(v[1] == 1){ // dans l'exploitation
						return v[0];
					}
					return 0;
				}
			};
			pptc.run();
			
		}
		if(dataReplantations != null){
			
			pptc = new Pixel2PixelTabCalculation(dataBoisement, dataBoisement, dataReplantations){
				@Override
				protected float doTreat(float[] v) {
					return Math.max(v[0], v[1]);
				}
			};
			pptc.run();
			
		}
		
		return dataBoisement;
	}
	
	public static double f(double v){
		return Math.log10(9*v+1);
	}
	
	public static CsvWriter prepareIndices(String outputCsv) {
		
		Util.createAccess(outputCsv);
		
		try {
			CsvWriter cw = new CsvWriter(outputCsv);
			cw.setDelimiter(';');
			
			cw.write("exploitation");
			cw.write("scenario");
			cw.write("secteur");
			cw.write("nb_pixel");
			cw.write("surface");
			cw.write("surface_boisement");
			cw.write("surface_arbre");
			cw.write("surface_haie");
			cw.write("surface_massif");
			cw.write("tx_boisement");
			cw.write("tx_arbre");
			cw.write("tx_haie");
			cw.write("tx_massif");
			cw.write("surface_interne");
			cw.write("surface_boisement_interne");
			cw.write("surface_arbre_interne");
			cw.write("surface_haie_interne");
			cw.write("surface_massif_interne");
			cw.write("tx_boisement_interne");
			cw.write("tx_arbre_interne");
			cw.write("tx_haie_interne");
			cw.write("tx_massif_interne");
			cw.write("surface_externe");
			cw.write("surface_boisement_externe");
			cw.write("surface_arbre_externe");
			cw.write("surface_haie_externe");
			cw.write("surface_massif_externe");
			cw.write("tx_boisement_externe");
			cw.write("tx_arbre_externe");
			cw.write("tx_haie_externe");
			cw.write("tx_massif_externe");
			cw.write("gb");
			cw.write("gb_externe");
			cw.write("delta_gb");
			cw.write("gb_fin");
			cw.write("gb_fonctionnel");
			cw.write("gb_potentiel");
			cw.write("gb_grossier");
			cw.write("tx_gb_fin");
			cw.write("tx_gb_fonctionnel");
			cw.write("tx_gb_potentiel");
			cw.write("tx_gb_grossier");
			cw.write("gb_fin_externe");
			cw.write("gb_fonctionnel_externe");
			cw.write("gb_potentiel_externe");
			cw.write("gb_grossier_externe");
			cw.write("tx_gb_fin_externe");
			cw.write("tx_gb_fonctionnel_externe");
			cw.write("tx_gb_potentiel_externe");
			cw.write("tx_gb_grossier_externe");
			cw.write("delta_gb_fin");
			cw.write("delta_gb_fonctionnel");
			cw.write("delta_gb_potentiel");
			cw.write("delta_gb_grossier");
			cw.write("tx_delta_gb_fin");
			cw.write("tx_delta_gb_fonctionnel");
			cw.write("tx_delta_gb_potentiel");
			cw.write("tx_delta_gb_grossier");
			cw.write("seuil_gb");
			cw.write("seuil_gb_externe");
			cw.write("delta_seuil_gb");
			cw.write("tx_seuil_gb");
			cw.write("tx_seuil_gb_externe");
			cw.write("tx_delta_seuil_gb");
			
			cw.endRecord();
				
			return cw;
			
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return null;
	}

	private void calculIndices(CsvWriter writer, String scenario, String secteur, float[] dataParcellaire, float[] dataHauteurBoisement, float[] dataTypeBoisement, 
			float[] dataGrainBocager, float[] dataGrainBocager4Classes, float[] dataGrainBocagerExterne, float[] dataGrainBocagerExterne4Classes, double cellsize) {

		System.out.println("calculs des indices");
		
		try {
			int nb = 0;
			int nbBoisement = 0;
			int nbArbre = 0;
			int nbHaie = 0;
			int nbMassif = 0;
			int nbInterne = 0;
			int nbBoisementInterne = 0;
			int nbArbreInterne = 0;
			int nbHaieInterne = 0;
			int nbMassifInterne = 0;
			int nbExterne = 0;
			int nbBoisementExterne = 0;
			int nbArbreExterne = 0;
			int nbHaieExterne = 0;
			int nbMassifExterne = 0;
			int nbGrain1 = 0;
			int nbGrain2 = 0;
			int nbGrain3 = 0;
			int nbGrainExterne1 = 0;
			int nbGrainExterne2 = 0;
			int nbGrainExterne3 = 0;
			double grainBocager = 0;
			double grainBocagerExterne = 0;
			double deltaGrainBocager = 0;
			for(int i=0; i<dataParcellaire.length; i++){
				if(dataParcellaire[i] > 0){
					nb++;
					if(dataHauteurBoisement[i] > 0) {
						nbBoisement++;
						if(dataTypeBoisement[i] == 1) {
							nbArbre++;
						}else if(dataTypeBoisement[i] == 5) {
							nbMassif++;
						}else if(dataTypeBoisement[i] == 10) {
							nbHaie++;
						}
					}
					
					if(dataParcellaire[i] == 1){ // en interne
						nbInterne++;
						if(dataHauteurBoisement[i] > 0) {
							nbBoisementInterne++;
							if(dataTypeBoisement[i] == 1) {
								nbArbreInterne++;
							}else if(dataTypeBoisement[i] == 5) {
								nbMassifInterne++;
							}else if(dataTypeBoisement[i] == 10) {
								nbHaieInterne++;
							}
						}
					}
					if(dataParcellaire[i] == 2){ // en externe
						nbExterne++;
						if(dataHauteurBoisement[i] > 0) {
							nbBoisementExterne++;
							if(dataTypeBoisement[i] == 1) {
								nbArbreExterne++;
							}else if(dataTypeBoisement[i] == 5) {
								nbMassifExterne++;
							}else if(dataTypeBoisement[i] == 10) {
								nbHaieExterne++;
							}
						}
					}
					
					grainBocager += dataGrainBocager[i];
					grainBocagerExterne += dataGrainBocagerExterne[i];
					
					deltaGrainBocager += (dataGrainBocagerExterne[i] - dataGrainBocager[i]);
					
					if(dataGrainBocager4Classes[i] == 1) {
						nbGrain1++;
					}else if(dataGrainBocager4Classes[i] == 2) {
						nbGrain2++;
					}else if(dataGrainBocager4Classes[i] == 3) {
						nbGrain3++;
					}
					
					if(dataGrainBocagerExterne4Classes[i] == 1) {
						nbGrainExterne1++;
					}else if(dataGrainBocagerExterne4Classes[i] == 2) {
						nbGrainExterne2++;
					}else if(dataGrainBocagerExterne4Classes[i] == 3) {
						nbGrainExterne3++;
					}
				}
				
			}
			
			double surface = (nb * Math.pow(cellsize, 2))/10000.0;
			double surfaceBoisement = (nbBoisement * Math.pow(cellsize, 2))/10000.0;
			double surfaceArbre = (nbArbre * Math.pow(cellsize, 2))/10000.0;
			double surfaceHaie = (nbHaie * Math.pow(cellsize, 2))/10000.0;
			double surfaceMassif = (nbMassif * Math.pow(cellsize, 2))/10000.0;
			double txBoisement = (nbBoisement*100.0) / nb;
			double txArbre = (nbArbre*100.0) / nb;
			double txHaie = (nbHaie*100.0) / nb;
			double txMassif = (nbMassif*100.0) / nb;
			
			double surfaceInterne = (nbInterne * Math.pow(cellsize, 2))/10000.0;
			double surfaceBoisementInterne = (nbBoisementInterne * Math.pow(cellsize, 2))/10000.0;
			double surfaceArbreInterne = (nbArbreInterne * Math.pow(cellsize, 2))/10000.0;
			double surfaceHaieInterne = (nbHaieInterne * Math.pow(cellsize, 2))/10000.0;
			double surfaceMassifInterne = (nbMassifInterne * Math.pow(cellsize, 2))/10000.0;
			double txBoisementInterne = (nbBoisementInterne*100.0) / nbInterne;
			double txArbreInterne = (nbArbreInterne*100.0) / nbInterne;
			double txHaieInterne = (nbHaieInterne*100.0) / nbInterne;
			double txMassifInterne = (nbMassifInterne*100.0) / nbInterne;
			
			double surfaceExterne = (nbExterne * Math.pow(cellsize, 2))/10000.0;
			double surfaceBoisementExterne = (nbBoisementExterne * Math.pow(cellsize, 2))/10000.0;
			double surfaceArbreExterne = (nbArbreExterne * Math.pow(cellsize, 2))/10000.0;
			double surfaceHaieExterne = (nbHaieExterne * Math.pow(cellsize, 2))/10000.0;
			double surfaceMassifExterne = (nbMassifExterne * Math.pow(cellsize, 2))/10000.0;
			double txBoisementExterne = (nbBoisementExterne*100.0) / nbExterne;
			double txArbreExterne = (nbArbreExterne*100.0) / nbExterne;
			double txHaieExterne = (nbHaieExterne*100.0) / nbExterne;
			double txMassifExterne = (nbMassifExterne*100.0) / nbExterne;
			
			double moyGrainBocager = ((double) grainBocager) / nb;
			double moyGrainBocagerExterne = ((double) grainBocagerExterne) / nb;
			
			double surfaceGrainBocagerFin = (nbGrain1 * Math.pow(cellsize, 2))/10000.0;
			double surfaceGrainBocagerFonctionnel = (nbGrain2 * Math.pow(cellsize, 2))/10000.0;
			double surfaceGrainBocagerPotentiel = (nbGrain3 * Math.pow(cellsize, 2))/10000.0;
			double surfaceGrainBocagerGrossier = ((nb-nbGrain1-nbGrain2-nbGrain3) * Math.pow(cellsize, 2))/10000.0;
			
			double moyenneGrainBocagerFin = (surfaceGrainBocagerFin*100.0) / nb;
			double moyenneGrainBocagerFonctionnel = (surfaceGrainBocagerFonctionnel*100.0) / nb;
			double moyenneGrainBocagerPotentiel = (surfaceGrainBocagerPotentiel*100.0) / nb;
			double moyenneGrainBocagerGrossier = (surfaceGrainBocagerGrossier*100.0) / nb;
			
			double surfaceGrainBocagerFinExterne = (nbGrainExterne1 * Math.pow(cellsize, 2))/10000.0;
			double surfaceGrainBocagerFonctionnelExterne = (nbGrainExterne2 * Math.pow(cellsize, 2))/10000.0;
			double surfaceGrainBocagerPotentielExterne = (nbGrainExterne3 * Math.pow(cellsize, 2))/10000.0;
			double surfaceGrainBocagerGrossierExterne = ((nb-nbGrainExterne1-nbGrainExterne2-nbGrainExterne3) * Math.pow(cellsize, 2))/10000.0;
			
			double moyenneGrainBocagerFinExterne = (surfaceGrainBocagerFinExterne*100.0) / nb;
			double moyenneGrainBocagerFonctionnelExterne = (surfaceGrainBocagerFonctionnelExterne*100.0) / nb;
			double moyenneGrainBocagerPotentielExterne = (surfaceGrainBocagerPotentielExterne*100.0) / nb;
			double moyenneGrainBocagerGrossierExterne = (surfaceGrainBocagerGrossierExterne*100.0) / nb;
			
			double deltaGrainBocagerFin = surfaceGrainBocagerFin - surfaceGrainBocagerFinExterne;
			double deltaGrainBocagerFonctionnel = surfaceGrainBocagerFonctionnel - surfaceGrainBocagerFonctionnelExterne;
			double deltaGrainBocagerPotentiel = surfaceGrainBocagerPotentiel - surfaceGrainBocagerPotentielExterne;
			double deltaGrainBocagerGrossier = surfaceGrainBocagerGrossier - surfaceGrainBocagerGrossierExterne;
			
			double moyenneDeltaGrainBocagerFin = (deltaGrainBocagerFin*100.0) / nb;
			double moyenneDeltaGrainBocagerFonctionnel = (deltaGrainBocagerFonctionnel*100.0) / nb;
			double moyenneDeltaGrainBocagerPotentiel = (deltaGrainBocagerPotentiel*100.0) / nb;
			double moyenneDeltaGrainBocagerGrossier = (deltaGrainBocagerGrossier*100.0) / nb;
			
			double moyDeltaGrainBocager = (deltaGrainBocager*100.0) / nb;
			double indiceSeuilGrainBocager = nbGrain1*3 + nbGrain2*2 + nbGrain3;
			double indiceSeuilGrainBocagerExterne = nbGrainExterne1*3 + nbGrainExterne2*2 + nbGrainExterne3;
			double deltaSeuilGrainBocager = indiceSeuilGrainBocager - indiceSeuilGrainBocagerExterne;
			double moyenneSeuilGrainBocager = (indiceSeuilGrainBocager*100.0) / nb;
			double moyenneSeuilGrainBocagerExterne = (indiceSeuilGrainBocagerExterne*100.0) / nb;
			double moyenneDeltaSeuilGrainBocager = (deltaSeuilGrainBocager*100.0) / nb;
			
			writer.write(codeEA);
			writer.write(scenario);
			writer.write(secteur);
			writer.write(format.format(nb)+"");
			writer.write(format.format(surface)+"");
			writer.write(format.format(surfaceBoisement)+"");
			writer.write(format.format(surfaceArbre)+"");
			writer.write(format.format(surfaceHaie)+"");
			writer.write(format.format(surfaceMassif)+"");
			writer.write(format.format(txBoisement)+"");
			writer.write(format.format(txArbre)+"");
			writer.write(format.format(txHaie)+"");
			writer.write(format.format(txMassif)+"");
			
			writer.write(format.format(surfaceInterne)+"");
			writer.write(format.format(surfaceBoisementInterne)+"");
			writer.write(format.format(surfaceArbreInterne)+"");
			writer.write(format.format(surfaceHaieInterne)+"");
			writer.write(format.format(surfaceMassifInterne)+"");
			writer.write(format.format(txBoisementInterne)+"");
			writer.write(format.format(txArbreInterne)+"");
			writer.write(format.format(txHaieInterne)+"");
			writer.write(format.format(txMassifInterne)+"");
			
			writer.write(format.format(surfaceExterne)+"");
			writer.write(format.format(surfaceBoisementExterne)+"");
			writer.write(format.format(surfaceArbreExterne)+"");
			writer.write(format.format(surfaceHaieExterne)+"");
			writer.write(format.format(surfaceMassifExterne)+"");
			writer.write(format.format(txBoisementExterne)+"");
			writer.write(format.format(txArbreExterne)+"");
			writer.write(format.format(txHaieExterne)+"");
			writer.write(format.format(txMassifExterne)+"");
			
			writer.write(format.format(moyGrainBocager)+"");
			writer.write(format.format(moyGrainBocagerExterne)+"");
			writer.write(format.format(moyDeltaGrainBocager)+"");
			
			writer.write(format.format(surfaceGrainBocagerFin)+"");
			writer.write(format.format(surfaceGrainBocagerFonctionnel)+"");
			writer.write(format.format(surfaceGrainBocagerPotentiel)+"");
			writer.write(format.format(surfaceGrainBocagerGrossier)+"");
			
			writer.write(format.format(moyenneGrainBocagerFin)+"");
			writer.write(format.format(moyenneGrainBocagerFonctionnel)+"");
			writer.write(format.format(moyenneGrainBocagerPotentiel)+"");
			writer.write(format.format(moyenneGrainBocagerGrossier)+"");
			
			writer.write(format.format(surfaceGrainBocagerFinExterne)+"");
			writer.write(format.format(surfaceGrainBocagerFonctionnelExterne)+"");
			writer.write(format.format(surfaceGrainBocagerPotentielExterne)+"");
			writer.write(format.format(surfaceGrainBocagerGrossierExterne)+"");
			
			writer.write(format.format(moyenneGrainBocagerFinExterne)+"");
			writer.write(format.format(moyenneGrainBocagerFonctionnelExterne)+"");
			writer.write(format.format(moyenneGrainBocagerPotentielExterne)+"");
			writer.write(format.format(moyenneGrainBocagerGrossierExterne)+"");
			
			writer.write(format.format(deltaGrainBocagerFin)+"");
			writer.write(format.format(deltaGrainBocagerFonctionnel)+"");
			writer.write(format.format(deltaGrainBocagerPotentiel)+"");
			writer.write(format.format(deltaGrainBocagerGrossier)+"");
			
			writer.write(format.format(moyenneDeltaGrainBocagerFin)+"");
			writer.write(format.format(moyenneDeltaGrainBocagerFonctionnel)+"");
			writer.write(format.format(moyenneDeltaGrainBocagerPotentiel)+"");
			writer.write(format.format(moyenneDeltaGrainBocagerGrossier)+"");
			
			writer.write(format.format(indiceSeuilGrainBocager)+"");
			writer.write(format.format(indiceSeuilGrainBocagerExterne)+"");
			writer.write(format.format(deltaSeuilGrainBocager)+"");
			writer.write(format.format(moyenneSeuilGrainBocager)+"");
			writer.write(format.format(moyenneSeuilGrainBocagerExterne)+"");
			writer.write(format.format(moyenneDeltaSeuilGrainBocager)+"");
			
			writer.endRecord();
			
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	private void calculIndices(CsvWriter writer, String secteur, 
			float[] dataParcellaire, float[] grainBocagerTotal, float[] grainBocagerMinimum, float[] grainBocagerMaximum, 
			double cellsize) {

		System.out.println("calculs des indices");
		
		try {
			
			int nbPSeuilTotal = 0;
			//int nbPSeuilTotal_i = 0;
			//int nbPSeuilTotal_e = 0;
			
			int nbTotal = 0;
			int nbInterne = 0;
			double g3d = 0;
			double g3dMinimum = 0;
			double g3dMaximum = 0;
			for(int i=0; i<dataParcellaire.length; i++){
				if(dataParcellaire[i] >= 0){
					nbTotal++;
					
					g3d += grainBocagerTotal[i];
					g3dMinimum += grainBocagerMinimum[i];
					g3dMaximum += grainBocagerMaximum[i];
					
					if(grainBocagerTotal[i] <= seuil){
						nbPSeuilTotal++;	
					}
					/*
					if(grainBocagerInterne[i] <= seuil){
						nbPSeuilTotal_e++;	
					}else if(grainBocagerExterne[i] <= seuil){
						nbPSeuilTotal_i++;	
					}
					*/
					
					if(dataParcellaire[i] > 0){ 
						nbInterne++;
					}
				}
			}
			
			double surfaceEA = nbInterne*Math.pow(cellsize, 2)/10000.0;
			double surfacePaysage = nbTotal*Math.pow(cellsize, 2)/10000.0;
			double txEA = surfaceEA*100.0/surfacePaysage;
			
			double g3dFonctionnel = nbPSeuilTotal*Math.pow(cellsize, 2)/10000.0;
			double txg3dFonctionnel = g3dFonctionnel*100.0/surfacePaysage;
			
			double txg3dEA = (g3dMinimum-g3d)*100.0/(g3dMinimum-g3dMaximum);
			double responsabilite = txg3dEA/txEA;
			
			/*
			double g3d = nbPSeuilTotal*Math.pow(cellsize, 2)/10000.0;
			double g3dPropre = nbPSeuilTotal_e*Math.pow(cellsize, 2)/10000.0;
			double g3dExterne = nbPSeuilTotal_i*Math.pow(cellsize, 2)/10000.0;
			double g3dCombine = g3d - g3dPropre - g3dExterne;
			double g3dEA = g3dPropre + g3dCombine;
			double txg3d = g3d * 100.0 / surfacePaysage;
			double txg3dPropre = g3dPropre * 100.0 / g3d;
			double txg3dExterne = g3dExterne * 100.0 / g3d;
			double txg3dCombine = g3dCombine * 100.0 / g3d;
			double tg3dEA = txg3dPropre + txg3dCombine;
			double responsabilite = tg3dEA/txEA;
			*/
			//System.out.println(codeEA+" : "+txg3d+" : "+responsabilite);
			
			writer.write(codeEA);
			writer.write(secteur);
			writer.write(format.format(surfaceEA)+"");
			writer.write(format.format(surfacePaysage)+"");
			writer.write(format.format(txEA)+"");
			
			writer.write(format.format(txg3dFonctionnel)+"");
			writer.write(format.format(txg3dEA)+"");
			//writer.write(format.format(responsabilite)+"");
			
			System.out.println(g3dMinimum+" "+g3d+" "+g3dMaximum);
			System.out.println(codeEA+" : "+txg3dFonctionnel+" : "+responsabilite+" --> "+txg3dEA);
			
			/*
			writer.write(format.format(g3dPropre)+"");
			writer.write(format.format(g3dCombine)+"");
			writer.write(format.format(g3dExterne)+"");
			writer.write(format.format(g3dEA)+"");
			writer.write(format.format(g3d)+"");
			writer.write(format.format(txg3d)+"");
			writer.write(format.format(txg3dPropre)+"");
			writer.write(format.format(txg3dCombine)+"");
			writer.write(format.format(txg3dExterne)+"");
			writer.write(format.format(tg3dEA)+"");
			writer.write(format.format(responsabilite)+"");
			*/
			
			writer.endRecord();
			
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	private String[] getSecteurs() {
		
		//System.out.println("recuperation des secteurs");
		
		try{
			ShpFiles sf = new ShpFiles(parcellaire);
			DbaseFileReader dfr = new DbaseFileReader(sf, true, Charset.defaultCharset());
			DbaseFileHeader header = dfr.getHeader();
			int ideaNumber = -1;
			int secteurNumber = -1;
			for(int i=0; i<header.getNumFields(); i++){
				if(header.getFieldName(i).equalsIgnoreCase(attributeCodeEA)){
					ideaNumber = i;
				}
				if(header.getFieldName(i).equalsIgnoreCase(attributeSecteur)){
					secteurNumber = i;
				}
			}
			if(secteurNumber == -1){
				throw new IllegalArgumentException("l'attribut '"+attributeSecteur+"' n'existe pas.");
			}
			if(ideaNumber == -1){
				throw new IllegalArgumentException("l'attribut '"+attributeCodeEA+"' n'existe pas.");
			}
			
			Set<String> secteurs = new TreeSet<String>();
			
			String code, secteur;
			Object[] entry;
			while(dfr.hasNext()){
				
				entry = dfr.readEntry();
				code = (String) entry[ideaNumber];
				secteur = (String) entry[secteurNumber];
				if(code.equalsIgnoreCase(codeEA)){
					secteurs.add(secteur);	
				}
			}
			
			dfr.close();
			
			String[] lesSecteurs = secteurs.toArray(new String[secteurs.size()]);
			
			return lesSecteurs;
			
		} catch (ShapefileException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}

	private Envelope getEnvelope(String secteur) {
		
		//System.out.println("r�cup�ration de l'enveloppe");
		
		double minx = Double.MAX_VALUE;
		double maxx = Double.MIN_VALUE;
		double miny = Double.MAX_VALUE;
		double maxy = Double.MIN_VALUE;
		
		try{
			ShpFiles sf = new ShpFiles(parcellaire);
			ShapefileReader sfr = new ShapefileReader(sf, true, false, new GeometryFactory());
			DbaseFileReader dfr = new DbaseFileReader(sf, true, Charset.defaultCharset());
			DbaseFileHeader header = dfr.getHeader();
			int ideaNumber = -1;
			int secteurNumber = -1;
			for(int i=0; i<header.getNumFields(); i++){
				if(header.getFieldName(i).equalsIgnoreCase(attributeCodeEA)){
					ideaNumber = i;
				}
				if(!secteur.equalsIgnoreCase("total") && header.getFieldName(i).equalsIgnoreCase(attributeSecteur)){
					secteurNumber = i;
				}
			}
			if(ideaNumber == -1){
				throw new IllegalArgumentException("l'attribut '"+attributeCodeEA+"' n'existe pas.");
			}
			if(!secteur.equalsIgnoreCase("total") && secteurNumber == -1){
				throw new IllegalArgumentException("l'attribut '"+attributeSecteur+"' n'existe pas.");
			}
			
			Geometry the_geom;
			String code, sec;
			Object[] entry;
			while(sfr.hasNext()){
				the_geom = (Geometry) sfr.nextRecord().shape();
				
				entry = dfr.readEntry();
				code = (String) entry[ideaNumber];
				if(code.equalsIgnoreCase(codeEA)){
					if(!secteur.equalsIgnoreCase("total")){
						sec = (String) entry[secteurNumber];
						if(sec.equalsIgnoreCase(secteur)){
							minx = Math.min(minx, the_geom.getEnvelopeInternal().getMinX());
							maxx = Math.max(maxx, the_geom.getEnvelopeInternal().getMaxX());
							miny = Math.min(miny, the_geom.getEnvelopeInternal().getMinY());
							maxy = Math.max(maxy, the_geom.getEnvelopeInternal().getMaxY());
						}
					}else{
						minx = Math.min(minx, the_geom.getEnvelopeInternal().getMinX());
						maxx = Math.max(maxx, the_geom.getEnvelopeInternal().getMaxX());
						miny = Math.min(miny, the_geom.getEnvelopeInternal().getMinY());
						maxy = Math.max(maxy, the_geom.getEnvelopeInternal().getMaxY());
					}	
				}
			}
			
			sfr.close();
			dfr.close();
			
			return new Envelope(minx-2*buffer, maxx+2*buffer, miny-2*buffer, maxy+2*buffer);
			
		} catch (ShapefileException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
	
	/*
	public static void main(String[] args){
		String attributeCodeEA = "id_ea";										// attribut de code exploitation
		String codeEA = "035177652"; 											// code exploitation
		String attributeSecteur = "secteur";									// attribut des secteurs
		String path = "G:/FDCCA/diag_ea/data/test/"; 							// dossier de g�n�ration des sorties
		String parcellaire = path+"data/exploitation.shp";						// shapefile du parcellaire de l'exploitation
		String zoneBocageExploitation = path+"data/bocage_exploitation.shp";	// shapefile des zones bocag�res appartenant � l'exploitation
		String bocage = "H:/temp/tile_coverage/mean/";							// tuiles MNHC
		String replantationBocagere = path+"data/replantations.shp";			// lineaire bocagere imagine
		double seuil = 0.4; 													// seuil de fonctionnalite du grain bocager
		
		String outputPath = path+"output5/";
		Util.createAccess(outputPath);
		
		// r�cup�ration de l'enveloppe totale de travail
		Envelope envelope = getEnvelope(parcellaire, attributeCodeEA, codeEA, attributeSecteur, "total", buffer);
		
		// recuperation des secteurs
		String[] secteurs = getSecteurs(parcellaire, attributeCodeEA, codeEA, attributeSecteur);
		
		// r�cup�ration de l'entete
		EnteteRaster refEntete = EnteteRaster.getEntete(envelope, 5, -1);
		
		// diagnostic situation initial
		runDiagnostic("existant", outputPath, secteurs, parcellaire, zoneBocageExploitation, null, attributeCodeEA, codeEA, attributeSecteur, bocage, seuil, refEntete);
		
		// diagnostic situation alternative
		runDiagnostic("scenario1", outputPath, secteurs, parcellaire, zoneBocageExploitation, replantationBocagere, attributeCodeEA, codeEA, attributeSecteur, bocage, seuil, refEntete);
			
		// test de proxy du PGDH base sur les volumes pseudo-locaux du MNHC 
		//proxyPGDH();
		
	}
	*/
	
	/*
	private static void proxyPGDH(){
		
		Coverage covHauteurBoisement = CoverageManager.getCoverage("G:/FDCCA/diag_ea/data/test/output5/hauteur_boisement_null.tif");
		float[] dataHauteurBoisement = covHauteurBoisement.getDatas();
		EnteteRaster entete = covHauteurBoisement.getEntete();
		covHauteurBoisement.dispose();
		
		Coverage covGrain = CoverageManager.getCoverage("G:/FDCCA/diag_ea/data/test/output5/grain_bocager_null.tif");
		float[] dataGrain = covGrain.getDatas();
		covGrain.dispose();
		
		float[] data = new float[entete.width()*entete.height()];
		
		LandscapeMetricAnalysisBuilder builder = new LandscapeMetricAnalysisBuilder();
		builder.setWindowDistanceType(WindowDistanceType.FAST_GAUSSIAN);
		
		builder.setRasterTab(dataHauteurBoisement);
		builder.setEntete(entete);
		
		builder.addMetric("average");
		builder.setWindowSize(21);
		builder.addTabOutput(data);
		
		LandscapeMetricAnalysis analysis = builder.build();
		
		analysis.allRun();
		
		Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(data, data){
			@Override
			protected float doTreat(float[] v) {
				return (float) (Math.min(v[0], 30.0) / 30.0);
			}
		};
		pptc.run();
		
		CoverageManager.writeGeotiff("G:/FDCCA/diag_ea/data/test/output5/average_MNHC.tif", data, entete);
		
		pptc = new Pixel2PixelTabCalculation(data, data, dataGrain){
			@Override
			protected float doTreat(float[] v) {
				return v[0] * (1 - v[1]);
			}
		};
		pptc.run();
		
		CoverageManager.writeGeotiff("G:/FDCCA/diag_ea/data/test/output5/qualite_bocage.tif", data, entete);
	}
	*/
	
}

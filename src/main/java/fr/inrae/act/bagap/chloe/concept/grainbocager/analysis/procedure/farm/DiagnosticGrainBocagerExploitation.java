package fr.inrae.act.bagap.chloe.concept.grainbocager.analysis.procedure.farm;

import java.io.IOException;
import java.nio.charset.Charset;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

import org.geotools.data.shapefile.dbf.DbaseFileHeader;
import org.geotools.data.shapefile.dbf.DbaseFileReader;
import org.geotools.data.shapefile.files.ShpFiles;
import org.geotools.data.shapefile.shp.ShapefileException;
import org.geotools.data.shapefile.shp.ShapefileReader;
import org.jumpmind.symmetric.csv.CsvWriter;
import org.locationtech.jts.geom.Envelope;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.GeometryFactory;

import fr.inra.sad.bagap.apiland.analysis.tab.Pixel2PixelTabCalculation;
import fr.inrae.act.bagap.chloe.concept.grainbocager.analysis.GrainBocager;
import fr.inrae.act.bagap.chloe.distance.analysis.euclidian.TabChamferDistanceAnalysis;
import fr.inrae.act.bagap.chloe.util.Util;
import fr.inrae.act.bagap.raster.Coverage;
import fr.inrae.act.bagap.raster.CoverageManager;
import fr.inrae.act.bagap.raster.EnteteRaster;
import fr.inrae.act.bagap.raster.converter.ShapeFile2CoverageConverter;

public class DiagnosticGrainBocagerExploitation {

	private static int buffer = 350; 	// buffer d'influence en metres 
										// 100m pour le calcul des distances
										// 250m pour la fenetre glissante 
	
	private static DecimalFormat format;
	static{
		DecimalFormatSymbols symbols = new DecimalFormatSymbols();
		symbols.setDecimalSeparator('.');
		format = new DecimalFormat("0.00", symbols);
	}
	
	private String outputPath; // dossier de generation des sorties
	
	private String parcellaire; // shapefile du parcellaire de l'exploitation
	
	private String zoneBocageExploitation; // shapefile des zones bocageres appartenant a l'exploitation
	
	private double bufferZoneBocageExploitation; // buffer autour du bocage de l'exploitation
	
	private String bocage; // tuiles MNHC
	
	private String attributeCodeEA; // attribut de code exploitation
	
	private String attributeSecteur; // attribut des secteurs
	
	private String codeEA; // code exploitation
	
	private double seuil; // seuil de fonctionnalite du grain bocager
	
	private String replantationBocagere; // lineaire bocagere imagine
	
	private Set<String> scenarios; // scenarios a tester
	
	private String[] secteurs;
	
	private EnteteRaster refEntete;
	
	private double outCellSize;
	
	private CsvWriter writer;					// writer sur fichier
	
	public DiagnosticGrainBocagerExploitation(String outputPath, String parcellaire, String zoneBocageExploitation, double bufferZoneBocageExploitation, 
			String bocage, String attributeCodeEA, String attributeSecteur, String codeEA, double seuil, String replantationBocagere, Set<String> scenarios, double outCellSize, CsvWriter writer){
		this.outputPath = outputPath;
		this.parcellaire = parcellaire;
		this.zoneBocageExploitation = zoneBocageExploitation;
		this.bufferZoneBocageExploitation = bufferZoneBocageExploitation;
		this.bocage = bocage;
		this.attributeCodeEA = attributeCodeEA;
		this.attributeSecteur = attributeSecteur;
		this.codeEA = codeEA;
		this.seuil = seuil;
		this.replantationBocagere = replantationBocagere;
		this.scenarios = scenarios;
		this.outCellSize = outCellSize;
		this.writer = writer;
	}
	
	public void run(){
		
		// creation du repertoire de sortie
		//Util.createAccess(outputPath);
		
		// recuperation de l'enveloppe totale de travail
		Envelope envelope = getEnvelope("total");
		
		if(envelope.getMaxX()-envelope.getMinX() > 15000
				|| envelope.getMaxY()-envelope.getMinY() > 15000){
			// do nothing
		}else{
			
			// recuperation des secteurs
			//secteurs = getSecteurs();
			
			// recuperation de l'entete
			Coverage covBocage = CoverageManager.getCoverage(bocage);
			refEntete = covBocage.getEntete();
			covBocage.dispose();
			refEntete = EnteteRaster.getEntete(refEntete, envelope);
			
			boolean externe = true;
			
			// diagnostic situation initial
			if(scenarios.contains("existant")){
				runDiagnostic("existant", null, externe);
			}
			
			/*
			if(replantationBocagere != null && !replantationBocagere.equalsIgnoreCase("")){
				for(String scenario : scenarios){
					if(!scenario.equalsIgnoreCase("existant")){
						// diagnostic situation alternative
						runDiagnostic(scenario, replantationBocagere);
					}
				}
			}*/
			
		}
	}
	
	private void runDiagnostic(String scenario, String replantationBocagere, boolean externe) {
		
		// preparation des indices de sortie
		boolean manageWriter = false;
		if(writer == null){
			writer = prepareIndices(outputPath+"diag_grain_bocager_"+codeEA+"_"+scenario+".csv");
			manageWriter = true;
		}
			
		// lancement du diagnostic
		runDiagnostic(scenario, "total", replantationBocagere, externe);
		
		/*
		// par secteur
		for(String secteur : secteurs){
			runDiagnostic(scenario, secteur, replantationBocagere, externe);
		}
		*/
		
		// fermeture du fichier de sortie
		if(manageWriter){
			fermeIndices(writer);
		}
	}
	
	private void runDiagnostic(String scenario, String secteur, String replantationBocagere, boolean externe) {
		
		// recuperation de l'enveloppe totale de travail
		Envelope envelope = getEnvelope(secteur);
		
		// recuperation de l'entete initiale
		EnteteRaster entete = EnteteRaster.getEntete(refEntete, envelope);
		
		// recuperation de la zone de bocage de l'exploitation
		float[] dataZoneBocageExploitation = getZoneBocageExploitation(entete, bufferZoneBocageExploitation);
		//CoverageManager.writeGeotiff(outputPath+"bocage_ea_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataZoneBocageExploitation, entete);
		
		// recuperation des replantations
		float[] dataReplantations = getReplantations(scenario, replantationBocagere, entete);
		//CoverageManager.writeGeotiff(outputPath+"replantations_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataReplantations, entete);
		 
		// grain total
		float[] dataHauteurBoisementTotal = getElementsBoises(dataZoneBocageExploitation, dataReplantations, entete, true, externe);
		CoverageManager.writeGeotiff(outputPath+"hauteur_boisement_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataHauteurBoisementTotal, entete);
		
		// calcul du grain bocager total
		Coverage covGrainBocagerTotal = GrainBocager.run(dataHauteurBoisementTotal, entete, outCellSize);
		float[] dataGrainBocagerTotal = covGrainBocagerTotal.getData();
		covGrainBocagerTotal.dispose();
		CoverageManager.writeGeotiff(outputPath+"grain_bocager_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataGrainBocagerTotal, entete);
		
		// recuperation du raster (5m) du parcellaire de l'exploitation
		// avec "1" = dans l'exploitation
		// "0" = externe a l'exploitation mais dans l'emprise d'influence (<350m)
		// "-1" = externe a l'emprise d'influence
		float[] dataParcellaire = getParcellaire(entete);
		CoverageManager.writeGeotiff(outputPath+"ea_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataParcellaire, entete);
		
		
		
		/*
		// calcul du grain bocager total
		Coverage covGrainBocagerTotal = GrainBocager.run(dataHauteurBoisementTotal, entete, outCellSize);
		float[] dataGrainBocagerTotal = covGrainBocagerTotal.getData();
		EnteteRaster outEntete = covGrainBocagerTotal.getEntete();
		covGrainBocagerTotal.dispose();
		CoverageManager.writeGeotiff(outputPath+"grain_bocager_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataGrainBocagerTotal, outEntete);
		
		float[] dataGrainBocagerInterne = null;
		
		// grain interne
		//float[] dataHauteurBoisementInterne = getElementsBoises(dataZoneBocageExploitation, dataReplantations, entete, true, false);
		//CoverageManager.writeGeotiff(outputPath+"hauteur_boisement_interne_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataHauteurBoisementInterne, entete);
		
		// calcul du grain bocager interne
		//Coverage covGrainBocagerInterne = GrainBocager.calculate(dataHauteurBoisementInterne, entete, outCellSize);
		//float[] dataGrainBocagerInterne = covGrainBocagerInterne.getDatas();
		//covGrainBocagerInterne.dispose();
		//CoverageManager.writeGeotiff(outputPath+"grain_bocager_interne_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataGrainBocagerInterne, outEntete);
		
		
		// grain minimum
		float[] dataHauteurBoisementMinimum = getElementsBoises(dataZoneBocageExploitation, dataReplantations, entete, false, externe);
		CoverageManager.writeGeotiff(outputPath+"hauteur_boisement_minimum_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataHauteurBoisementMinimum, entete);
						
		// calcul du grain bocager minimum
		Coverage covGrainBocagerMinimum = GrainBocager.run(dataHauteurBoisementMinimum, entete, outCellSize);
		float[] dataGrainBocagerMinimum = covGrainBocagerMinimum.getData();
		covGrainBocagerMinimum.dispose();
		CoverageManager.writeGeotiff(outputPath+"grain_bocager_minimum_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataGrainBocagerMinimum, outEntete);
		
		// grain maximum
		float[] dataHauteurBoisementMaximum = getElementsBoisesMaximum(dataZoneBocageExploitation, dataReplantations, entete, externe);
		CoverageManager.writeGeotiff(outputPath+"hauteur_boisement_maximum_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataHauteurBoisementMaximum, entete);
								
		// calcul du grain bocager maximum
		Coverage covGrainBocagerMaximum = GrainBocager.run(dataHauteurBoisementMaximum, entete, outCellSize);
		float[] dataGrainBocagerMaximum = covGrainBocagerMaximum.getData();
		covGrainBocagerMaximum.dispose();
		CoverageManager.writeGeotiff(outputPath+"grain_bocager_maximum_"+secteur+"_"+codeEA+"_"+scenario+".tif", dataGrainBocagerMaximum, outEntete);
		
		*/
		
		// calcul des indices et export
		//calculIndices(writer, secteur, dataParcellaire, dataGrainBocagerTotal, dataGrainBocagerMinimum, dataGrainBocagerMaximum, outCellSize);
		
	}
	
	private float[] getReplantations(String scenario, String replantationBocagere, EnteteRaster entete){
		
		if(replantationBocagere != null){
			//System.out.println("r�cup�ration des replantations");
			
			Map<String, String> conditions = new TreeMap<String, String>();
			conditions.put(attributeCodeEA, codeEA); 
			conditions.put(scenario, "1");
			
			Coverage covReplantation = ShapeFile2CoverageConverter.getLinearCoverage(replantationBocagere, conditions, 10, entete.cellsize(), entete.noDataValue(), entete.crs(), entete.minx(), entete.maxx(), entete.miny(), entete.maxy(), 0, entete.cellsize());
			float[] dataReplantation = covReplantation.getData();
			covReplantation.dispose();
			
			return dataReplantation;
		}
		
		return null;
	}

	/**
	 * r�cup�ration du raster (5m) du parcellaire de l'exploitation avec 
	 * "1" = dans l'exploitation
	 * "0" = externe � l'exploitation mais dans l'emprise d'influence (<350m)
	 * "-1" = externe � l'emprise d'influence
	 */
	private float[] getParcellaire(EnteteRaster entete) {
		
		//System.out.println("r�cup�ration du parcellaire");
		
		Map<String, Integer> codesEA = new HashMap<String, Integer>();
		codesEA.put(codeEA, 1);
		
		Coverage covParcellaire = ShapeFile2CoverageConverter.getSurfaceCoverage(parcellaire, attributeCodeEA, codesEA, entete.cellsize(), entete.noDataValue(), entete.crs(), entete.minx(), entete.maxx(), entete.miny(), entete.maxy(), 0);
		float[] dataParcellaire = covParcellaire.getData();
		covParcellaire.dispose();
	
		int[] codes =  new int[]{1};
		float[] dataDistance = new float[entete.width() * entete.height()];
		
		TabChamferDistanceAnalysis da = new TabChamferDistanceAnalysis(dataDistance, dataParcellaire, entete.width(), entete.height(), entete.cellsize(), entete.noDataValue(), codes, entete.noDataValue());
		da.allRun();
		
		dataParcellaire = null;
		
		float[] data = new float[entete.width() * entete.height()];
		Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(data, dataDistance){
			@Override
			protected float doTreat(float[] v) {
				double value = v[0];
				if(value == 0){ // dans l'exploitation
					return 1;
				}
				if(value <= buffer){ // dans la zone d'influence
					return 0;
				}
				return entete.noDataValue();
			}
		};
		pptc.run();
		
		return data;
	}
	
	private float[] getZoneBocageExploitation(EnteteRaster entete, double buffer) {

		//System.out.println("r�cup�ration de la zone de bocage de l'exploitation");
		
		Map<String, Integer> codesEA = new HashMap<String, Integer>();
		codesEA.put(codeEA, 1);
		
		Coverage covZoneBocage = ShapeFile2CoverageConverter.getSurfaceCoverage(zoneBocageExploitation, attributeCodeEA, codesEA, entete.cellsize(), entete.noDataValue(), entete.crs(), entete.minx(), entete.maxx(), entete.miny(), entete.maxy(), 0);
		float[] dataZoneBocage = covZoneBocage.getData();
		covZoneBocage.dispose();
		
		if(buffer > 0){
			int[] codes =  new int[]{1};
			float[] dataDistance = new float[entete.width() * entete.height()];
			
			TabChamferDistanceAnalysis da = new TabChamferDistanceAnalysis(dataDistance, dataZoneBocage, entete.width(), entete.height(), entete.cellsize(), entete.noDataValue(), codes, entete.noDataValue());
			da.allRun();
			
			Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(dataZoneBocage, dataDistance){
				@Override
				protected float doTreat(float[] v) {
					double value = v[0];
					if(value == 0){ // dans l'exploitation
						return 1;
					}
					if(value <= buffer){ // dans la zone d'influence
						return 1;
					}
					return 0;
				}
			};
			pptc.run();
		}
		
		return dataZoneBocage;
	}
	
	private float[] getElementsBoises(float[] dataZoneBocageExploitation, float[] dataReplantations, EnteteRaster entete, boolean interne, boolean externe) {
		return getElementsBoises(dataZoneBocageExploitation, dataReplantations, entete, interne, externe, -1);
	}
	
	private float[] getElementsBoises(float[] dataZoneBocageExploitation, float[] dataReplantations, EnteteRaster entete, boolean interne, boolean externe, int scenar) {
		
		//System.out.println("recuperation des elements boises");
		
		Coverage covBoisement = CoverageManager.getCoverage(bocage);
		EnteteRaster enteteMNHC = covBoisement.getEntete();
		float[] dataBoisement = covBoisement.getData(EnteteRaster.getROI(enteteMNHC, new Envelope(entete.minx(), entete.maxx(), entete.miny(), entete.maxy())));
		covBoisement.dispose();
		
		if(!interne){
			
			Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(dataBoisement, dataBoisement, dataZoneBocageExploitation){
				@Override
				protected float doTreat(float[] v) {
					if(v[1] == 1){ // dans l'exploitation
						return 0;
					}
					return v[0];
				}
			};
			pptc.run();
			
		}
		if(!externe){
			
			Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(dataBoisement, dataBoisement, dataZoneBocageExploitation){
				@Override
				protected float doTreat(float[] v) {
					if(v[1] == 1){ // dans l'exploitation
						return v[0];
					}
					return 0;
				}
			};
			pptc.run();
			
		}
		if(interne && dataReplantations != null){
			
			Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(dataBoisement, dataBoisement, dataReplantations){
				@Override
				protected float doTreat(float[] v) {
					return Math.max(v[0], v[1]);
				}
			};
			pptc.run();
			
		}
		
		return dataBoisement;
	}
	
	private float[] getElementsBoisesMaximum(float[] dataZoneBocageExploitation, float[] dataReplantations, EnteteRaster entete, boolean externe) {
		return getElementsBoisesMaximum(dataZoneBocageExploitation, dataReplantations, entete, externe, -1);
	}
	
	private float[] getElementsBoisesMaximum(float[] dataZoneBocageExploitation, float[] dataReplantations, EnteteRaster entete, boolean externe, int scenar) {
		
		//System.out.println("recuperation des elements boises");
		
		Coverage covBoisement = CoverageManager.getCoverage(bocage);
		EnteteRaster enteteMNHC = covBoisement.getEntete();
		float[] dataBoisement = covBoisement.getData(EnteteRaster.getROI(enteteMNHC, new Envelope(entete.minx(), entete.maxx(), entete.miny(), entete.maxy())));
		covBoisement.dispose();
		
		Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(dataBoisement, dataBoisement, dataZoneBocageExploitation){
			@Override
			protected float doTreat(float[] v) {
				if(v[1] == 1){ // dans l'exploitation
					return 10;
				}
				return v[0];
			}
		};
		pptc.run();
			
		if(!externe){
			
			pptc = new Pixel2PixelTabCalculation(dataBoisement, dataBoisement, dataZoneBocageExploitation){
				@Override
				protected float doTreat(float[] v) {
					if(v[1] == 1){ // dans l'exploitation
						return v[0];
					}
					return 0;
				}
			};
			pptc.run();
			
		}
		if(dataReplantations != null){
			
			pptc = new Pixel2PixelTabCalculation(dataBoisement, dataBoisement, dataReplantations){
				@Override
				protected float doTreat(float[] v) {
					return Math.max(v[0], v[1]);
				}
			};
			pptc.run();
			
		}
		
		return dataBoisement;
	}
	
	public static CsvWriter prepareIndices(String outputCsv) {
		
		Util.createAccess(outputCsv);
		
		try {
			CsvWriter cw = new CsvWriter(outputCsv);
			cw.setDelimiter(';');
			
			cw.write("exploitation");
			cw.write("secteur");
			cw.write("surface_ea");
			cw.write("surface_paysage");
			cw.write("tx_ea");
			
			cw.write("tx_g3d_fonctionnel");
			cw.write("tx_g3d_exploitation");
			//cw.write("responsabilite");
			
			//cw.write("g3d_total");
			//cw.write("g3d_externe");
			//cw.write("g3d_interne");
			
			/*
			cw.write("g3d_propre");
			cw.write("g3d_combine");
			cw.write("g3d_externe");
			cw.write("g3d_ea");
			cw.write("g3d");
			cw.write("tx_g3d");
			cw.write("tx_g3d_propre");
			cw.write("tx_g3d_combine");
			cw.write("tx_g3d_externe");
			cw.write("tx_g3d_ea");
			cw.write("responsabilite");
			*/
			
			cw.endRecord();
				
			return cw;
			
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		return null;
	}
	
	public static double f(double v){
		return Math.log10(9*v+1);
	}
	
	private void calculIndices(CsvWriter writer, String secteur, float[] dataParcellaire, float[] grainBocagerTotal, float[] grainBocagerMinimum, float[] grainBocagerMaximum, double cellsize) {

		System.out.println("calculs des indices");
		
		try {
			
			int nbPSeuilTotal = 0;
			//int nbPSeuilTotal_i = 0;
			//int nbPSeuilTotal_e = 0;
			
			int nbTotal = 0;
			int nbInterne = 0;
			double g3d = 0;
			double g3dMinimum = 0;
			double g3dMaximum = 0;
			for(int i=0; i<dataParcellaire.length; i++){
				if(dataParcellaire[i] >= 0){
					nbTotal++;
					
					g3d += grainBocagerTotal[i];
					g3dMinimum += grainBocagerMinimum[i];
					g3dMaximum += grainBocagerMaximum[i];
					
					if(grainBocagerTotal[i] <= seuil){
						nbPSeuilTotal++;	
					}
					/*
					if(grainBocagerInterne[i] <= seuil){
						nbPSeuilTotal_e++;	
					}else if(grainBocagerExterne[i] <= seuil){
						nbPSeuilTotal_i++;	
					}
					*/
					
					if(dataParcellaire[i] > 0){ 
						nbInterne++;
					}
				}
			}
			
			double surfaceEA = nbInterne*Math.pow(cellsize, 2)/10000.0;
			double surfacePaysage = nbTotal*Math.pow(cellsize, 2)/10000.0;
			double txEA = surfaceEA*100.0/surfacePaysage;
			
			double g3dFonctionnel = nbPSeuilTotal*Math.pow(cellsize, 2)/10000.0;
			double txg3dFonctionnel = g3dFonctionnel*100.0/surfacePaysage;
			
			double txg3dEA = (g3dMinimum-g3d)*100.0/(g3dMinimum-g3dMaximum);
			double responsabilite = txg3dEA/txEA;
			
			/*
			double g3d = nbPSeuilTotal*Math.pow(cellsize, 2)/10000.0;
			double g3dPropre = nbPSeuilTotal_e*Math.pow(cellsize, 2)/10000.0;
			double g3dExterne = nbPSeuilTotal_i*Math.pow(cellsize, 2)/10000.0;
			double g3dCombine = g3d - g3dPropre - g3dExterne;
			double g3dEA = g3dPropre + g3dCombine;
			double txg3d = g3d * 100.0 / surfacePaysage;
			double txg3dPropre = g3dPropre * 100.0 / g3d;
			double txg3dExterne = g3dExterne * 100.0 / g3d;
			double txg3dCombine = g3dCombine * 100.0 / g3d;
			double tg3dEA = txg3dPropre + txg3dCombine;
			double responsabilite = tg3dEA/txEA;
			*/
			//System.out.println(codeEA+" : "+txg3d+" : "+responsabilite);
			
			writer.write(codeEA);
			writer.write(secteur);
			writer.write(format.format(surfaceEA)+"");
			writer.write(format.format(surfacePaysage)+"");
			writer.write(format.format(txEA)+"");
			
			writer.write(format.format(txg3dFonctionnel)+"");
			writer.write(format.format(txg3dEA)+"");
			//writer.write(format.format(responsabilite)+"");
			
			System.out.println(g3dMinimum+" "+g3d+" "+g3dMaximum);
			System.out.println(codeEA+" : "+txg3dFonctionnel+" : "+responsabilite+" --> "+txg3dEA);
			
			/*
			writer.write(format.format(g3dPropre)+"");
			writer.write(format.format(g3dCombine)+"");
			writer.write(format.format(g3dExterne)+"");
			writer.write(format.format(g3dEA)+"");
			writer.write(format.format(g3d)+"");
			writer.write(format.format(txg3d)+"");
			writer.write(format.format(txg3dPropre)+"");
			writer.write(format.format(txg3dCombine)+"");
			writer.write(format.format(txg3dExterne)+"");
			writer.write(format.format(tg3dEA)+"");
			writer.write(format.format(responsabilite)+"");
			*/
			
			writer.endRecord();
			
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	private String[] getSecteurs() {
		
		//System.out.println("recuperation des secteurs");
		
		try{
			ShpFiles sf = new ShpFiles(parcellaire);
			DbaseFileReader dfr = new DbaseFileReader(sf, true, Charset.defaultCharset());
			DbaseFileHeader header = dfr.getHeader();
			int ideaNumber = -1;
			int secteurNumber = -1;
			for(int i=0; i<header.getNumFields(); i++){
				if(header.getFieldName(i).equalsIgnoreCase(attributeCodeEA)){
					ideaNumber = i;
				}
				if(header.getFieldName(i).equalsIgnoreCase(attributeSecteur)){
					secteurNumber = i;
				}
			}
			if(secteurNumber == -1){
				throw new IllegalArgumentException("l'attribut '"+attributeSecteur+"' n'existe pas.");
			}
			if(ideaNumber == -1){
				throw new IllegalArgumentException("l'attribut '"+attributeCodeEA+"' n'existe pas.");
			}
			
			Set<String> secteurs = new TreeSet<String>();
			
			String code, secteur;
			Object[] entry;
			while(dfr.hasNext()){
				
				entry = dfr.readEntry();
				code = (String) entry[ideaNumber];
				secteur = (String) entry[secteurNumber];
				if(code.equalsIgnoreCase(codeEA)){
					secteurs.add(secteur);	
				}
			}
			
			dfr.close();
			
			String[] lesSecteurs = secteurs.toArray(new String[secteurs.size()]);
			
			return lesSecteurs;
			
		} catch (ShapefileException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}

	private Envelope getEnvelope(String secteur) {
		
		//System.out.println("r�cup�ration de l'enveloppe");
		
		double minx = Double.MAX_VALUE;
		double maxx = Double.MIN_VALUE;
		double miny = Double.MAX_VALUE;
		double maxy = Double.MIN_VALUE;
		
		try{
			ShpFiles sf = new ShpFiles(parcellaire);
			ShapefileReader sfr = new ShapefileReader(sf, true, false, new GeometryFactory());
			DbaseFileReader dfr = new DbaseFileReader(sf, true, Charset.defaultCharset());
			DbaseFileHeader header = dfr.getHeader();
			int ideaNumber = -1;
			int secteurNumber = -1;
			for(int i=0; i<header.getNumFields(); i++){
				if(header.getFieldName(i).equalsIgnoreCase(attributeCodeEA)){
					ideaNumber = i;
				}
				if(!secteur.equalsIgnoreCase("total") && header.getFieldName(i).equalsIgnoreCase(attributeSecteur)){
					secteurNumber = i;
				}
			}
			if(ideaNumber == -1){
				throw new IllegalArgumentException("l'attribut '"+attributeCodeEA+"' n'existe pas.");
			}
			if(!secteur.equalsIgnoreCase("total") && secteurNumber == -1){
				throw new IllegalArgumentException("l'attribut '"+attributeSecteur+"' n'existe pas.");
			}
			
			Geometry the_geom;
			String code, sec;
			Object[] entry;
			while(sfr.hasNext()){
				the_geom = (Geometry) sfr.nextRecord().shape();
				
				entry = dfr.readEntry();
				code = (String) entry[ideaNumber];
				if(code.equalsIgnoreCase(codeEA)){
					if(!secteur.equalsIgnoreCase("total")){
						sec = (String) entry[secteurNumber];
						if(sec.equalsIgnoreCase(secteur)){
							minx = Math.min(minx, the_geom.getEnvelopeInternal().getMinX());
							maxx = Math.max(maxx, the_geom.getEnvelopeInternal().getMaxX());
							miny = Math.min(miny, the_geom.getEnvelopeInternal().getMinY());
							maxy = Math.max(maxy, the_geom.getEnvelopeInternal().getMaxY());
						}
					}else{
						minx = Math.min(minx, the_geom.getEnvelopeInternal().getMinX());
						maxx = Math.max(maxx, the_geom.getEnvelopeInternal().getMaxX());
						miny = Math.min(miny, the_geom.getEnvelopeInternal().getMinY());
						maxy = Math.max(maxy, the_geom.getEnvelopeInternal().getMaxY());
					}	
				}
			}
			
			sfr.close();
			dfr.close();
			
			return new Envelope(minx-2*buffer, maxx+2*buffer, miny-2*buffer, maxy+2*buffer);
			
		} catch (ShapefileException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
	
	/*
	public static void main(String[] args){
		String attributeCodeEA = "id_ea";										// attribut de code exploitation
		String codeEA = "035177652"; 											// code exploitation
		String attributeSecteur = "secteur";									// attribut des secteurs
		String path = "G:/FDCCA/diag_ea/data/test/"; 							// dossier de g�n�ration des sorties
		String parcellaire = path+"data/exploitation.shp";						// shapefile du parcellaire de l'exploitation
		String zoneBocageExploitation = path+"data/bocage_exploitation.shp";	// shapefile des zones bocag�res appartenant � l'exploitation
		String bocage = "H:/temp/tile_coverage/mean/";							// tuiles MNHC
		String replantationBocagere = path+"data/replantations.shp";			// lineaire bocagere imagine
		double seuil = 0.4; 													// seuil de fonctionnalite du grain bocager
		
		String outputPath = path+"output5/";
		Util.createAccess(outputPath);
		
		// r�cup�ration de l'enveloppe totale de travail
		Envelope envelope = getEnvelope(parcellaire, attributeCodeEA, codeEA, attributeSecteur, "total", buffer);
		
		// recuperation des secteurs
		String[] secteurs = getSecteurs(parcellaire, attributeCodeEA, codeEA, attributeSecteur);
		
		// r�cup�ration de l'entete
		EnteteRaster refEntete = EnteteRaster.getEntete(envelope, 5, -1);
		
		// diagnostic situation initial
		runDiagnostic("existant", outputPath, secteurs, parcellaire, zoneBocageExploitation, null, attributeCodeEA, codeEA, attributeSecteur, bocage, seuil, refEntete);
		
		// diagnostic situation alternative
		runDiagnostic("scenario1", outputPath, secteurs, parcellaire, zoneBocageExploitation, replantationBocagere, attributeCodeEA, codeEA, attributeSecteur, bocage, seuil, refEntete);
			
		// test de proxy du PGDH base sur les volumes pseudo-locaux du MNHC 
		//proxyPGDH();
		
	}
	*/
	
	/*
	private static void proxyPGDH(){
		
		Coverage covHauteurBoisement = CoverageManager.getCoverage("G:/FDCCA/diag_ea/data/test/output5/hauteur_boisement_null.tif");
		float[] dataHauteurBoisement = covHauteurBoisement.getDatas();
		EnteteRaster entete = covHauteurBoisement.getEntete();
		covHauteurBoisement.dispose();
		
		Coverage covGrain = CoverageManager.getCoverage("G:/FDCCA/diag_ea/data/test/output5/grain_bocager_null.tif");
		float[] dataGrain = covGrain.getDatas();
		covGrain.dispose();
		
		float[] data = new float[entete.width()*entete.height()];
		
		LandscapeMetricAnalysisBuilder builder = new LandscapeMetricAnalysisBuilder();
		builder.setWindowDistanceType(WindowDistanceType.FAST_GAUSSIAN);
		
		builder.setRasterTab(dataHauteurBoisement);
		builder.setEntete(entete);
		
		builder.addMetric("average");
		builder.setWindowSize(21);
		builder.addTabOutput(data);
		
		LandscapeMetricAnalysis analysis = builder.build();
		
		analysis.allRun();
		
		Pixel2PixelTabCalculation pptc = new Pixel2PixelTabCalculation(data, data){
			@Override
			protected float doTreat(float[] v) {
				return (float) (Math.min(v[0], 30.0) / 30.0);
			}
		};
		pptc.run();
		
		CoverageManager.writeGeotiff("G:/FDCCA/diag_ea/data/test/output5/average_MNHC.tif", data, entete);
		
		pptc = new Pixel2PixelTabCalculation(data, data, dataGrain){
			@Override
			protected float doTreat(float[] v) {
				return v[0] * (1 - v[1]);
			}
		};
		pptc.run();
		
		CoverageManager.writeGeotiff("G:/FDCCA/diag_ea/data/test/output5/qualite_bocage.tif", data, entete);
	}
	*/
	
	
	
	public static void fermeIndices(CsvWriter writer){
		writer.close();
	}
	
}
